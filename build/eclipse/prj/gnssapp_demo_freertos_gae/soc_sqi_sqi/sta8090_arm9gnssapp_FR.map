MEMORY
{
  code(rx) : org = 0x10000000, len = 0x00100000
  nvm_data(rx) : org = 0x10100000, len = 0x00080000
  itcm_area(rx) : org = 0x0, len = 0x40000 - 0x28000
  dtcm_area(w) : org = 0x100000, len = 0x28000
  sram2(rw) : org = 0x30100000, len = 0x800
  sram(rw) : org = 0x40000000, len = 0x7C00
  sram_stdby(rw) : org = 0x40007C00, len = 0x400
  os_stack_area(w) : org = 0x100000 + 0x28000, len = 0
}
__dtcm_area_limit__ = 0x100000 + 0x28000;
__os_stack_area_limit__ = ORIGIN(os_stack_area) + LENGTH(os_stack_area);
_code_alignment_ = 16;
SECTIONS
{
  . = 0;
  .text = .;
  .text :
  {
    __code_area_start__ = .;
    KEEP( *(.reset_vector_area))
  } > code
  constructors :
  {
    PROVIDE(__init_array_start = 0);
    KEEP( *(SORT(.init_array.*)))
    KEEP( *(.init_array))
    PROVIDE(__init_array_end = 0);
  } > code
  destructors :
  {
    PROVIDE(__fini_array_start = 0);
    KEEP( *(SORT(.fini_array.*)))
    KEEP( *(.fini_array))
    PROVIDE(__fini_array_end = 0);
  } > code
  .ARM.extab :
  {
    *(.ARM.extab* .gnu_linkonce.armextab.*)
  } > code
  .text :
  {
    *( .text.startup.*)
    *(.glue_7t)
    *(.glue_7)
    *(.gcc*)
    *.o ( GENERIC_NORELOC_REGION)
  } > code
  .eh_frame :
  {
    . = ALIGN(16);
    __code_load_reg_start__ = .;
  } > code
  .itcm_text :
  {
    __code_exec_reg_start__ = .;
    KEEP( *(.vector_table))
    *svc.o ( .text* .rodata*)
    *svci.o ( .text* .rodata*)
    * ( OS_FAST_REGION)
    *.o ( GENERIC_CODE_ISR_REGION)
    *.o ( GENERIC_DATA_ISR_REGION)
    *.o ( OS_ISR_REGION)
    *.o ( MTU_ISR_REGION)
    *.o ( VIC_ISR_REGION)
    *.o ( DATA_ISR_REGION)
    *.o ( GNSSDSP_ISR_REGION)
    *.o ( SSP_ISR_REGION)
    *.o ( ADC_ISR_REGION)
    *.o ( UART_ISR_REGION)
    *.o ( USB_ISR_REGION)
    *.o ( GPIO_ISR_REGION)
    *svc_usb.o ( .rodata*)
    *queue.o ( .text.xQueueGiveFromISR)
    *queue.o ( .text.prvNotifyQueueSetContainer)
    *queue.o ( .text.prvCopyDataToQueue)
    *tasks.o ( .text.xTaskPriorityDisinherit)
    *lib*_s.a:lib_a-memcpy*.o ( .text.memcpy)
    *tasks.o ( .text.xTaskRemoveFromEventList)
    *queue.o ( .text.xQueueGenericSend)
    *tasks.o ( .text.xTaskGetSchedulerState)
    *tasks.o ( .text.vTaskSetTimeOutState)
    *tasks.o ( .text.vTaskSuspendAll)
    *tasks.o ( .text.xTaskCheckForTimeOut)
    *queue.o ( .text.prvIsQueueFull)
    *queue.o ( .text.vTaskPlaceOnEventList)
    *tasks.o ( .text.prvAddCurrentTaskToDelayedList)
    *queue.o ( .text.prvUnlockQueue)
    *tasks.o ( .text.vTaskMissedYield)
    *tasks.o ( .text.xTaskResumeAll)
    *queue.o ( .text.uxQueueMessagesWaitingFromISR)
    *queue.o ( .text.uxQueueMessagesWaiting)
    *tasks.o ( .text.xTaskGetCurrentTaskHandle)
    *queue.o ( .text.xQueueGenericSendFromISR)
    *tasks.o ( .text.vTaskSwitchContext)
    *tasks.o ( .text.xTaskIncrementTick)
    *tasks.o ( .text.prvResetNextTaskUnblockTime)
    *list.o ( .text.uxListRemove)
    *list.o ( .text.vListInsert)
    *list.o ( .text.vListInsertEnd)
    *queue.o ( .text.xQueueReceiveFromISR)
    *queue.o ( .text.prvCopyDataFromQueue)
    *tasks.o ( .text.xTaskResumeFromISR)
    *tasks.o ( .text.prvTaskIsTaskSuspended)
    *interrupti.o ( .text* .rodata*)
    *portISR.o ( .text* .rodata*)
    *FR_time.o ( .text* .rodata*)
    *OS20toOS_*.o ( .text* .rodata*)
    *_udivsi3.o ( .text* .rodata*)
    *_arm_muldivdf3.o ( .text* .rodata*)
    *lld_sqi*.o ( .text* .rodata*)
    *svc_sqi.o ( FLASH_MODIFY_REGION)
  } > itcm_area AT > code
  .itcm_text :
  {
    *position.o ( .data .data.* .ramtext .bss .bss.*)
    *fix.o ( .data .data.* .ramtext .bss .bss.*)
    *waas_correction.o ( .data .data.* .ramtext .bss .bss.*)
    *waas_iono.o ( .data .data.* .ramtext .bss .bss.*)
  } > itcm_area AT > code
  . = ALIGN(16);
  __code_exec_reg_end__ = .;
  __data_load_reg_start__ = __code_load_reg_start__ + __code_exec_reg_end__;
  .data : ALIGN(16)
  {
    __data_exec_reg_start__ = .;
    *(.data)
    . = ALIGN(16);
    *(.data.*)
    . = ALIGN(16);
    *(.ramtext)
    . = ALIGN(16);
    __data_exec_reg_end__ = .;
  } > dtcm_area AT > code
  .bss : ALIGN(16)
  {
    __bss_start__ = .;
    *(.bss)
    . = ALIGN(16);
    *(.bss.*)
    . = ALIGN(16);
    *(COMMON)
    . = ALIGN(16);
    __bss_end__ = .;
  } > dtcm_area
  __dtcm_area_end__ = .;
  __os_heap_area_start__ = .;
  .rodata :
  {
    *(.rodata*)
    . = ALIGN(4);
  } > code
  .ARM.exidx :
  {
    PROVIDE( __exidx_start = .);
    *( .ARM.exidx* .gnu_linkonce.armexidx.*)
    . = ALIGN(4);
    PROVIDE( __exidx_end = .);
  } > code
  . = ALIGN(16);
  __data_sram2_load_reg_start__ = .;
  .nvm (NOLOAD) :
  {
    __nvm_data_start__ = .;
    *(NVM_DATA_REGION)
    __nvm_data_end__ = .;
  } > nvm_data
  .sram_stdby_area(NOLOAD):
  {
    __sram_stdby_start__ = .;
    *(SRAM_STDBY_AREA)
    __sram_stdby_end__ = .;
  } > sram_stdby
  .sram2_area : ALIGN(16)
  {
     __sram2_start__ = .;
     *(SRAM2_AREA)
     . = ALIGN(16);
     __sram2_end__ = .;
  } > sram2 AT > code
   __data_sram_load_reg_start__ = __data_sram2_load_reg_start__ + (__sram2_end__ - __sram2_start__);
  .sram_area : ALIGN(16)
  {
     __sram_start__ = .;
     *(SRAM_AREA)
     . = ALIGN(16);
     __sram_end__ = .;
  } > sram AT > code
}
PROVIDE(end = .);
_end = .;
