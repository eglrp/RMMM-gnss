/*********************************************************************************************
   FILE:          POW_app.c
----------------------------------------------------------------------------------------------
   DESCRIPTION: Every 15 seconds, application print out its activity
                Every 10 seconds, GNSS activity perform a fix
----------------------------------------------------------------------------------------------
   COPYRIGHT:     (c) 2016 STMicroelectronics
 **********************************************************************************************/



/*****************************************************************************
   includes
 *****************************************************************************/
#include "macros.h"       /* to use BACKUP area           */
#include "gnss_api.h"     /* to use GNSS api              */
#include "gnss_defs.h"
#include "gnss_debug.h"   /* to send data to debug port   */
#include "svc_pwr.h"      /* to use power services        */
#include "svc_uart.h"
#include "gpOS_wakelock.h"/* to use wakelock services     */
#include "gnssapp.h"      /* to configure power services  */
#include "clibs.h"        /* to use clibs memory services */
#include "lld_rtc.h"      /* to use RTC                   */
#include "lld_gpio.h"
#include "gnss_events.h"
#include "gnss_data.h"
#include "POW_app.h"
#if defined( NVM_NOR ) || defined( NVM_SQI )
#include "gps_nvm_swap_mgr.h"
#endif
#include "gps_nvm.h"

/* define DEMO_USE_FREERTOS_API into make file to use FreeRTOS API instead of gpOS API */

#if !defined (DEMO_USE_FREERTOS_API)
#include "gpOS.h"         /* to use OS related functions  */
#endif

/*****************************************************************************
   defines and macros (scope: module-local)
 *****************************************************************************/
#define POW_APP_TASK_STACK_SIZE   15000     /* size of the sample application task stack */
#define POW_APPLICATION_ACTIVITY_PERIOD 3 /* Application wakeup period 10 seconds      */
#define POW_GNSS_ACTIVITY_PERIOD        4 /* GNSS        wakeup period 25 seconds      */
#define POW_RTC_TICKS_PER_SECOND   0x8000  /* RTC frac resolution */

#define _AT(x) x"\r\n"
#define PORT 1
#define PDN 1

#define BACKUP_ARRAY_SIZE 7

/*****************************************************************************
   global variable definitions
 *****************************************************************************/
tInt pow_app_task_priority = 0;   /* task priority value (value set arbitrary here)*/
#if defined (DEMO_USE_FREERTOS_API)
static TaskHandle_t xFrPOWAppProcess;
#endif

int COM_PORT = 0;
int MAX_READ_BUFFER_SIZE = 1500;

int fix_period_s=10;
int report_every_n_fixes = 2;

typedef struct pow_manager_t
{
    gpOS_wakelockid_t          wakelock_id;
    boolean_t             standby_wakeup;

}pow_manager_t;


/* Backup area declaration */
#if defined(__STA8090__)
#pragma arm section zidata = "SRAM_STDBY_DATA"
#endif
SRAM_STDBY_DATA gpOS_clock_t pow_next_timer_activity;     /* Next activity time */
SRAM_STDBY_DATA tUInt        pow_application_activity;    /* Activity counter   */
SRAM_STDBY_DATA tUInt        counter;
SRAM_STDBY_DATA Gnss_data    positions[8];
SRAM_STDBY_DATA Gnss_data    positions_backup[BACKUP_ARRAY_SIZE];
SRAM_STDBY_DATA Config       config;
SRAM_STDBY_DATA tUInt        n_positions_stored;
//SRAM_STDBY_DATA tUInt        testing;
//SRAM_STDBY_DATA char         imei[15];              // Fixed size
#if defined(__STA8090__)
#pragma arm section zidata
#endif


static pow_manager_t       pow_manager;

/*****************************************************************************
   function prototypes (scope: module-local)
 *****************************************************************************/
/* Function which is called by "POW_app_task" */
#if defined (DEMO_USE_FREERTOS_API)
static void pow_app_process( void *pvParameters );
#else
static gpOS_task_exit_status_t pow_app_process( void *p );
#endif
static void pow_print_activity(tUInt round);
static gpOS_clock_t pow_compute_next_activity(void);

/*****************************************************************************
   function implementations
 *****************************************************************************/
boolean_t wait_urc(char * urc, int max_retries){
  char buffer[2*MAX_READ_BUFFER_SIZE];
  boolean_t not_timedout = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  read_at(buffer, sizeof(buffer));

  while(!strstr(buffer, urc)){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      not_timedout = false;
      break;
    }
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }
  return not_timedout;
}



/* Creation of "POW_app_task" */
void pow_app_init(gpOS_partition_t *part)
{

  // Register on service power
  gpOS_wakelock_register( &pow_manager.wakelock_id );

  // Prevent standby entry by acquiring wakelock
  gpOS_wakelock_acquire(pow_manager.wakelock_id);

  /* COLD startup, activate low power mode */
  if( svc_pwr_StartupMode() == SVC_PWR_STARTUP_POWER_ON )
  {
    gnss_low_power_periodic_mode_t  periodic;
    gnss_low_power_cyclic_mode_t  cyclic;
    gnss_app_lowpow_standby_type_t Standby;

    /* Will illustrate the number of wakeup for Application activity */
    pow_application_activity = 0;

    /* Plan activity in POW_APPLICATION_ACTIVITY_PERIOD seconds */
    pow_next_timer_activity = gpOS_time_now();

    counter=0;
    n_positions_stored=0;
    //testing=0;


    config.fleet_id[0] = '0';                      // Empty in the COLD STARTUP
    strcpy(config.imei, "357353080001193");
    //config.imei[0] = '\0';
    config.fix_period_s = fix_period_s;
    config.report_every_n_fixes = report_every_n_fixes;

    //positions = malloc(sizeof(struct Gnss_data *) * config.report_every_n_fixes/config.fix_period_s); //Allocate array of x positions

    GPS_DEBUG_MSG( ( "[POW_app] COLD STARTUP, setup periodic mode with standby \r\n"));

    /* set periodic mode at period of 10 seconds */
    periodic.periodic_mode = TRUE;                  /* < Activate periodic mode           */
    periodic.RTC_refresh = 0;                       /* < No RTC refresh                   */
    periodic.EPH_refresh = 1;                       /* < Ephemeris refresh                */
    periodic.NoFixOffTime = 10;                     /* < wait fix during 60 seconds       */
    periodic.NoFixTimeout = 10;                     /* < if no fix retry after 60 seconds */
    periodic.fix_on_time = 1;                       /* < wait 1 fix                       */
    periodic.fix_period = config.fix_period_s; /* < provide a fix every 25 seconds   */

    GPS_DEBUG_MSG( ( "[POW_app] Provide %d fix every %d seconds \r\n",periodic.fix_on_time,periodic.fix_period));
    GPS_DEBUG_MSG( ( "[POW_app] Application activity synchronized with GNSS \r\n"));


    /* activate standby */
    Standby = GNSSAPP_LOW_POWER_STANDBY_ENABLE;

    /* disable cyclic mode */;
    _clibs_memset(&cyclic,0,sizeof(gnss_low_power_cyclic_mode_t));

    /* Activate GNSS periodic mode for a standby period of 10 seconds */
    gnssapp_low_power_setup_update( Standby , &cyclic, & periodic );               /* periodic setup */

  }
  /* Come back from standby state */
  /* STARTUP_WAKEUP_PIN or STARTUP_WAKEUP_RTC */
  else
  {
    gpOS_clock_t StandbyDuration_rtcbase;
    gpOS_clock_t VirtualPreviousOsTime;
    gpOS_clock_t TimeNow = gpOS_time_now();

    // Update previous timer value from backup ram
    svc_pwr_get_timer_adjustment( &StandbyDuration_rtcbase, &VirtualPreviousOsTime );

    GPS_DEBUG_MSG( ( "\r\n[POW_app] STARTUP - LEAVE STANDBY after %d second(s)-\r\n",StandbyDuration_rtcbase/gpOS_timer_ticks_per_sec()));

  }

  gpOS_task_create_p( part, pow_app_process, NULL, POW_APP_TASK_STACK_SIZE, pow_app_task_priority + 15, "POW_app_task", gpOS_TASK_FLAGS_ACTIVE );

  /* GPIO setup */
  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN0,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN0);

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN11,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN11);

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN13,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionOutput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN13);
  LLD_GPIO_SetStateLow( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN13 );

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN25,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_MODE_A);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN25);

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN26,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN26);

  /* Open UART port */
  if(svc_uart_open_port(COM_PORT, gpOS_INTERRUPT_NOPRIORITY, LLD_UART_115200_BPS, 256, 256, 4) == gpOS_FAILURE)
  {
    GPS_DEBUG_MSG(( "[POW_app] Open UART FAILED\r\n"));
  }
  else
  {
    GPS_DEBUG_MSG(( "[POW_app] Open UART OK\r\n"));
  }

}

boolean_t send_positions()
{

  /*if(testing==1){
    testing=0;
    return FALSE;
  }
  testing++;*/

  gpOS_clock_t socekt_at_timeout_ms = 5000;
  gpOS_clock_t std_at_timeout_ms = 100;

  flush_rx();

  at_check_signal_quality();
  at_check_pin_status();
  //send_at_wait_response(_AT("AT+CSQ"), "OK", 10);
  //send_at_wait_response(_AT("AT+CPIN?"), "OK", 10);

  if(!at_check_eps_registration_status()){
    report_error(" - No network");
    return FALSE;
  }

  if(!at_check_pdp_context()){
    report_error(" - No PDN");
    at_activate_pdp();
    return FALSE;
  }


  if(at_is_socket_closed(PORT)){
    if(!openSocket()){
      report_error(" - open socket failed");
      return FALSE;
    }
  }

  at_send_data(PORT);
  //send_packet_activate();
  send_http_package(positions, positions_backup, counter, n_positions_stored);
  //send_http_package();
  send_control_z();

  //GPS_DEBUG_MSG(( "[modem/listen] Listening\r\n"));
  if(!wait_urc("+SQNSRING", 1000000)){

  }else{
    //if(!at_recv_data(PORT,1500)){

    //}
    //need to flush rx since the OK\r\n in HTTP response triggered the AT parser to exit too soon
    flush_rx();

  }

  return TRUE;
}


/* Function which is called by "sample_app_task" */
static gpOS_task_exit_status_t pow_app_process( void *p )
{
  GPS_DEBUG_MSG( ( "[POW_app] Task is running\r\n"));

  GPS_DEBUG_MSG(( "[POW_app] Waiting for modem to become online... \r\n"));
  if(!wait_urc("+SYSSTART", 50)){
    report_error(" - +SYSSTART never received");
  }else{
    GPS_DEBUG_MSG(( "[POW_app] +SYSSTART Received \r\n"));
  }

  at_disable_echo();
  at_check();
  at_activate_modem();


  // Just need to config the sockets once
  if(!at_configure_socket(PORT,PDN,0,0,600,50)){
    report_error(" - sqnscfg failed");
    //return FALSE;
  }
  if(!at_extended_configure_socket(PORT,1,0,0)){
    report_error(" - sqnscfgext failed");
    //return FALSE;
  }
  gpOS_task_delay(1*1000*1000*gpOS_timer_ticks_per_usec()); //1 segundo?

  if(config.fleet_id[0]=='0'){            // Normally we come from a COLD STARTUP
    //char buffer[15];
    //at_get_imei(config.imei);  // DESCOMENTAR
    //config.imei = atoi(buffer);
    //activate_tracker(config.imei);
    GPS_DEBUG_MSG( ( "[POW_app] IMEI %s\r\n", config.imei));
  }else{
    GPS_DEBUG_MSG( ( "[POW_app] tracker already activated %s\r\n", config.imei));

  }

  while ( TRUE )
  {
    // Activity processing
    pow_print_activity(pow_application_activity ++);

    // Wait for standby wake-up, generated by GNSS periodic mode
    gpOS_wakelock_release(pow_manager.wakelock_id, gpOS_TIMEOUT_INFINITY );

    // suspend activity with a delay superior to GNSS period.
    gpOS_task_delay( 2 * config.fix_period_s * gpOS_timer_ticks_per_sec());

    // Prevent standby entry by acquiring wakelock
    gpOS_wakelock_acquire(pow_manager.wakelock_id);
  }
}
/* Function emulating the main application activity */
static void pow_print_activity(tUInt round)
{
  tU32 DRI,DRF;
  double ActivityTime;

  // Get RTC time
  LLD_RTC_Get_DRI_DRF_Registers(&DRI,&DRF);
  if(DRF > POW_RTC_TICKS_PER_SECOND)
  {
    DRF = POW_RTC_TICKS_PER_SECOND;
  }
  DRF = POW_RTC_TICKS_PER_SECOND - DRF;

  ActivityTime = ( DRI % 60 ) + (double)DRF/(double)POW_RTC_TICKS_PER_SECOND;

  GPS_DEBUG_MSG( ( "[POW_app] Task activity round %d Time : %.2f s\r\n",round, ActivityTime  ));

  gnss_fix_store_local(NULL);

  if(gnss_fix_get_pos_status() != NO_FIX)
  {
    position_t pos;
    velocity_t vel;


    gnss_fix_get_fil_pos_vel_local(&pos, &vel, NULL);
    char *timestamp = (char*) _clibs_malloc(26 * sizeof(char));
    at_get_network_time(timestamp);


    if(counter<config.report_every_n_fixes){
      GPS_DEBUG_MSG( ( "[POW_app] Position : %.5f, %.5f detected\r\n",pos.latitude, pos.longitude  ));
      GPS_DEBUG_MSG( ( "[POW_app] Saving... \r\n"  ));
      positions[counter].pos=pos;
      parse_date_response(timestamp);
      _clibs_strcpy(positions[counter].timestamp, timestamp);
      free(timestamp);
      GPS_DEBUG_MSG(( "[POW_app] After return, date=%s\r\n", positions[counter].timestamp));
      GPS_DEBUG_MSG( ( "[POW_app] Position saved \r\n"  ));
      counter++;
      if(counter>=config.report_every_n_fixes)
      {
        if(send_positions()==TRUE)
        {
          counter=0;
          n_positions_stored=0;
          _clibs_memset(positions, 0, sizeof(positions));
        }
        else
        {
          GPS_DEBUG_MSG( ( "[POW_app] Storing positions due to a network problem\r\n"  ));
          if(n_positions_stored>=BACKUP_ARRAY_SIZE) n_positions_stored=0;                                                            // Avoid overflow

          //_clibs_memcpy(&positions_backup[n_positions_stored*sizeof(positions)], &positions, n_positions_stored*sizeof(Gnss_data));  // Copy positions to backup
          //n_positions_stored+=counter;                                                                                               // Increase the index depending on how many positions we had
          //_clibs_memset(positions, 0, sizeof(positions));                                                                            // Clean positions array
          int i;
          for(i=0; i<counter; i++)
          {
            positions_backup[n_positions_stored+i]=positions[i];      // To not write over the old positions
            GPS_DEBUG_MSG(( "[POW_app] Storing %.8f  ,  %.8f  ,  %s\r\n", positions_backup[n_positions_stored+i].pos.latitude, positions_backup[n_positions_stored+i].pos.longitude, positions_backup[n_positions_stored+i].timestamp));
            n_positions_stored++;
          }
          _clibs_memset(positions, 0, sizeof(positions));
          GPS_DEBUG_MSG( ( "[POW_app] Stored\r\n"  ));
          counter=0;
        }
      }
    }

  }

  //GPS_DEBUG_MSG( ( "[POW_app] Posiciones : %.5f, %.5f \r\n",positions[counter-1].pos.latitude, positions[counter-1].pos.longitude  ));

  else{
    GPS_DEBUG_MSG( ( "[POW_app] No FIX yet \r\n" ));
  }

}

/* Function processing the duration before the next activity */
static gpOS_clock_t pow_compute_next_activity(void)
{
  gpOS_clock_t SleepDuration;
  gpOS_clock_t TimeNow;

  // Provide duration between NOW & next activity
  TimeNow = gpOS_time_now();

  if( gpOS_time_after( pow_next_timer_activity,  TimeNow ) != 0  )
  {
    SleepDuration = gpOS_time_minus( pow_next_timer_activity, TimeNow );
  }
  else
  {
    // Process activity NOW
    SleepDuration = 0;
  }

  return SleepDuration;
}

