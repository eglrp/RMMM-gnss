/*
 * connection_manager.c
 *
 *  Created on: 24 mai 2017
 *      Author: jsanchez
 */


#include "svc_uart.h"
#include "clibs.h"
#include "gnssapp.h"      /* to configure power services  */
#include "gnss_data.h"
#include "gnss_debug.h"
#include "gnss_api.h"     /* to use GNSS api              */
#include "libs/cJSON.h"
#include "libs/picohttpparser.h"
#include "POW_app.h"

//#define IMEI "8888888885"
#define latitude_s "48.85578817"
#define longitude_s "2.36069871"

#define GET_COMMAND "GET /http?imei="IMEI"&position="latitude_s","longitude_s" HTTP/1.1"
#define GET_COMMAND_SUBST "GET /http?imei="IMEI"&position=%2.8f,%1.8f HTTP/1.1"


#define FLEET_ID "5721489412194304"
#define IMEI "123456789012345"
#define POST_COMMAND_POSITION "POST /api/fleets/"FLEET_ID"/trackers/"IMEI"/positions HTTP/1.1"
#define POST_COMMAND_POSITION_SUBS "POST /api/fleets/%s/trackers/%s/positions HTTP/1.1"

#define CONTENT "Content-Length: 62\0"
#define CONTENT_SUBS "Content-Length: %d\0"

//#define PORT 1
#define PDN 1
#define _AT(x) x"\r\n"

int PORT = 1;

#define POST_COMMAND_BASE "POST /api/fleets/"fleet_id"/trackers/"
#define POST_COMMAND "POST /api/fleets/"fleet_id"/trackers/"imei"/positions HTTP/1.1"
#define POST_COMMAND_SUBST  "POST /api/fleets/"fleet_id"/trackers/ HTTP/1.1"
#define POST_COMMAND_POSITIONS "/positions HTTP/1.1"

char * HTTP_PACKAGE[] = { GET_COMMAND,
    "Host: 1.cloud-logger-159118.appspot.com",
    "Connection: keep-alive",
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.91 Safari/537.36",
    "X-Client-Data: CIm2yQEIprbJAQiptskBCMG2yQEInobKAQjsiMoB",
    "Accept-Encoding: gzip, deflate, sdch",
    "Accept-Language: es,en-US;q=0.8,en;q=0.6,fr;q=0.4"};


char * HTTP_POST_PACKAGE[] = {
    "Host: cloud-logger-159118.appspot.com",
    "Accept: */*",
    "User-Agent: runscope/0.1",
    "Accept-Encoding: gzip, deflate, sdch"

};

boolean_t openSocket(){

  // Just need to config the sockets once
  if(!at_configure_socket(PORT,PDN,0,0,600,50)){
    report_error(" - sqnscfg failed");
    //return FALSE;
  }
  if(!at_extended_configure_socket(PORT,1,0,0)){
    report_error(" - sqnscfgext failed");
    //return FALSE;
  }

  if(!send_at_wait_response(_AT("at+sqnsd=1,0,80,\"cloud-logger-159118.appspot.com\",0,8000,1"),"OK", 150)){
    report_error(" - sqnsd failed");
    return FALSE;
  }
}

void send_control_z(){
  send_at_get_response("\032", gpOS_TIMEOUT_IMMEDIATE);
  //send_at( "\032");
}

void apply_new_config(){

  gnss_low_power_periodic_mode_t  periodic;
  gnss_low_power_cyclic_mode_t  cyclic;
  gnss_app_lowpow_standby_type_t Standby;

  _clibs_memset(&periodic,0,sizeof(gnss_low_power_periodic_mode_t));

  /* set periodic mode at period of 10 seconds */
  periodic.periodic_mode = TRUE;                  /* < Activate periodic mode           */
  periodic.RTC_refresh = 0;                       /* < No RTC refresh                   */
  periodic.EPH_refresh = 1;                       /* < Ephemeris refresh                */
  periodic.NoFixOffTime = 10;                     /* < wait fix during 60 seconds       */
  periodic.NoFixTimeout = 10;                     /* < if no fix retry after 60 seconds */
  periodic.fix_on_time = 1;                       /* < wait 1 fix                       */
  periodic.fix_period = config.fix_period_s; /* < provide a fix every 25 seconds   */

  /* disable cyclic mode */;
  _clibs_memset(&cyclic,0,sizeof(gnss_low_power_cyclic_mode_t));

  Standby = GNSSAPP_LOW_POWER_STANDBY_ENABLE;

  gnssapp_low_power_setup_update( Standby , &cyclic, & periodic );               /* periodic setup */

  GPS_DEBUG_MSG(( "[POW_app] Setting fix_period_s to %d and report_every_n_fixes to %d\r\n", config.fix_period_s, config.report_every_n_fixes));

}

void set_new_config(char * json){
  cJSON *root = cJSON_Parse(json);

  cJSON *included = cJSON_GetObjectItemCaseSensitive(root, "included");
  cJSON *data = cJSON_GetObjectItemCaseSensitive(root, "data");

  if(included) // Coming for new config
  {
    cJSON *attributes = cJSON_GetArrayItem(included, 0);
    cJSON *attributes_item = cJSON_GetObjectItemCaseSensitive(attributes, "attributes");
    cJSON *config_item = cJSON_GetObjectItemCaseSensitive(attributes_item, "config");
    cJSON *report_every_n_fixes_item = cJSON_GetObjectItemCaseSensitive(config_item, "report_every_n_fixes");
    cJSON *fix_period_s_item = cJSON_GetObjectItemCaseSensitive(config_item, "fix_period_s");
    cJSON *fleet_id_item = cJSON_GetObjectItemCaseSensitive(attributes_item, "fleet");

    if (cJSON_IsNumber(report_every_n_fixes_item)){
      config.report_every_n_fixes = report_every_n_fixes_item->valueint;
    }
    if (cJSON_IsNumber(fix_period_s_item))
    {
      config.fix_period_s = fix_period_s_item->valueint;
    }
  }
  else if(data) // Coming from tracker activation
  {
    cJSON *attributes_item = cJSON_GetObjectItemCaseSensitive(data, "attributes");
    cJSON *config_item = cJSON_GetObjectItemCaseSensitive(attributes_item, "config");
    cJSON *report_every_n_fixes_item = cJSON_GetObjectItemCaseSensitive(config_item, "report_every_n_fixes");
    cJSON *fix_period_s_item = cJSON_GetObjectItemCaseSensitive(config_item, "fix_period_s");
    cJSON *fleet_id_item = cJSON_GetObjectItemCaseSensitive(attributes_item, "fleet");

    if (cJSON_IsNumber(report_every_n_fixes_item))
    {
      config.report_every_n_fixes = report_every_n_fixes_item->valueint;
    }
    if (cJSON_IsNumber(fix_period_s_item))
    {
      config.fix_period_s = fix_period_s_item->valueint;
    }
    if (cJSON_IsNumber(fleet_id_item))
    {
      //char *buffer = fleet_id_item->valuestring;
      char *buffer = Itoa(fleet_id_item->valueint);
      _clibs_strcpy(config.fleet_id, buffer);
      GPS_DEBUG_MSG(( "[POW_app] fleet = %s\r\n", buffer));
      GPS_DEBUG_MSG(( "[POW_app] fleet = %d\r\n", fleet_id_item->valueint));
    }
    GPS_DEBUG_MSG(( "[POW_app] Tracker activated with fleet = %s\r\n", config.fleet_id));
  }


  free(json);
  cJSON_Delete(root);
  apply_new_config();
}



void analyse_response(char * response){

  GPS_DEBUG_MSG(( "[POW_app] Response %s\r\n", response));

  int i;
  size_t num_headers=0;
  for(i=0;i<mystrlen(response)-7; i++){
    if(response[i]=='\r' && response[i+1]=='\n' && response[i+2]!='\r'){      //TO-DO Could be done better (count just before the payload to avoid fake positives)
      num_headers++;
    }
  }

  int minor_version;
  int status;
  const char *msg;
  size_t msg_len;
  struct phr_header headers[num_headers];



  int pret;
  while (1) {

    // parse the reponse
    pret = phr_parse_response(response, strlen(response), &minor_version, &status, &msg, &msg_len, headers, &num_headers, 0);
    if (pret > 0)
      break;  //successfully parsed the request
    else if (pret == -1){
      GPS_DEBUG_MSG(( "[POW_app] PARSING ERROR\r\n"));
      break;
    }
    // request is incomplete, continue the loop
  }

  //GPS_DEBUG_MSG(( "[POW_app] respuesta %s\r\n", response));

  int payload_size = mystrlen(response)-pret+1;
  char payload[1500];
  switch (status){
    case 201:         // CREATED -> new config
      GPS_DEBUG_MSG(( "[POW_app] Code 201 detected, searching the payload... \r\n"));
      memcpy(payload, response + pret, payload_size);
      payload[payload_size] = '\0';
      GPS_DEBUG_MSG(( "[POW_app] payload = %s\r\n", payload));
      set_new_config(payload);
      break;
    case 204:         // NO CONTENT -> nothing special
      GPS_DEBUG_MSG(( "[POW_app] Positions well received by the cloud server\r\n"));
      break;
    default:          // NOT EXPECTED / ERROR
      GPS_DEBUG_MSG(( "[POW_app] ERROR: The cloud server answered with a code %d\r\n", status));
      break;
  }

  free(response);

}

void send_packet_activate(){
  char post_init[50] = "PATCH /api/trackers/000000000000000 HTTP/1.1\0";         // Base pointer to store the real imei
  _clibs_sprintf(post_init, "PATCH /api/trackers/%s HTTP/1.1\0", config.imei);
  char * http_post_init_tracker[] = {
      post_init,
      "Host: cloud-logger-159118.appspot.com",
      "Accept: */*",
      "User-Agent: runscope/0.1",
      "Accept-Encoding: gzip, deflate, sdch"

  };

  cJSON *root;
  cJSON *data;
  cJSON *attributes;
  root = cJSON_CreateObject();
  cJSON_AddItemToObject(root, "data", data = cJSON_CreateObject());
  cJSON_AddStringToObject(data, "type", "trackers");
  char * e;
  errno = 0;
  long long int n = strtoll(config.imei, &e, 0);
  cJSON_AddNumberToObject(data, "id", n);
  cJSON_AddItemToObject(data, "attributes", attributes = cJSON_CreateObject());
  cJSON_AddBoolToObject(attributes, "activated", true);
  cJSON_AddBoolToObject(attributes, "remote", true);

  char *rendered = cJSON_Print(root);
  remove_all_chars(rendered, '\n');
  remove_all_chars(rendered, '\t');
  remove_all_chars(rendered, '\r');

  //Sending header

  //tU8 buff[] = POST_COMMAND;

  send_at(post_init);
  send_at("\r\n");

  int i;
  for(i=1; i<(sizeof(http_post_init_tracker)/sizeof(*http_post_init_tracker)); i++){
    send_at(http_post_init_tracker[i]);
    send_at("\r\n");
  }

  //Content-Length
  int length_payload = mystrlen(rendered);
  char str[18];
  _clibs_sprintf(str, "Content-Length: %d\0", length_payload);
  send_at(str);

  send_at("\r\n");
  send_at("\r\n");

  // HEADER FINISHED

  send_at(rendered);

  cJSON_Delete(root);

  send_at("\r\n");
  send_at("\r\n");
}

boolean_t activate_tracker(){

  gpOS_clock_t socekt_at_timeout_ms = 5000;
  gpOS_clock_t std_at_timeout_ms = 100;

  flush_rx();

  at_check_signal_quality();
  at_check_pin_status();
  //send_at_wait_response(_AT("AT+CSQ"), "OK", 10);
  //send_at_wait_response(_AT("AT+CPIN?"), "OK", 10);

  //gpOS_task_delay(3*1000*1000*gpOS_timer_ticks_per_usec()); //1 segundo?
  gpOS_task_delay(5*1000*1000*gpOS_timer_ticks_per_usec()); //1 segundo?

  if(!at_check_eps_registration_status()){
    report_error(" - No network");
    return FALSE;
  }

  if(!at_check_pdp_context()){
    report_error(" - No PDN");
    at_activate_pdp();
    return FALSE;
  }


  if(at_is_socket_closed(PORT)){
    if(!openSocket()){
      report_error(" - open socket failed");
      return FALSE;
    }
  }

  at_send_data(PORT);
  send_packet_activate();
  //send_http_package();
  send_control_z();

  //GPS_DEBUG_MSG(( "[modem/listen] Listening\r\n"));
  if(!wait_urc("+SQNSRING", 1000000)){

  }else{
    //if(!at_recv_data(PORT,1500)){

    //}
    //need to flush rx since the OK\r\n in HTTP response triggered the AT parser to exit too soon
    flush_rx();

  }

  return TRUE;


}


void send_http_package(Gnss_data *positions, Gnss_data *positions_backup, tUInt n_positions, tUInt n_positions_stored){

  //Building the body (needed for Content-Length)

  cJSON *root;
  cJSON *data;
  root = cJSON_CreateObject();
  cJSON_AddItemToObject(root, "data", data = cJSON_CreateArray());

  int i;
  for(i=0; i<n_positions; i++){
    cJSON *position;
    cJSON *geopoint;
    cJSON *created_on;
    cJSON *attributes;
    cJSON_AddItemToArray(data, position = cJSON_CreateObject());
    cJSON_AddStringToObject(position, "type", "positions");
    cJSON_AddItemToObject(position, "attributes", attributes = cJSON_CreateObject());
    GPS_DEBUG_MSG(( "[POW_app] The latitude, longitude and timestamp are %.8f  ,  %.8f  ,  %s\r\n", positions[i].pos.latitude, positions[i].pos.longitude, positions[i].timestamp));
    char str[20];
    _clibs_sprintf(str, "%.8f,%.8f\0", positions[i].pos.latitude,positions[i].pos.longitude);
    cJSON_AddStringToObject(attributes, "geo_point", str);
    cJSON_AddStringToObject(attributes, "created_on", positions[i].timestamp);

  }

  // Adding the backup positions if any
  for(i=0;i<n_positions_stored;i++){
    cJSON *position;
    cJSON *geopoint;
    cJSON *created_on;
    cJSON *attributes;
    cJSON_AddItemToArray(data, position = cJSON_CreateObject());
    cJSON_AddStringToObject(position, "type", "positions");
    cJSON_AddItemToObject(position, "attributes", attributes = cJSON_CreateObject());
    GPS_DEBUG_MSG(( "[POW_app] EXTRA The latitude, longitude and timestamp are %.8f  ,  %.8f  ,  %s\r\n", positions_backup[i].pos.latitude, positions_backup[i].pos.longitude, positions_backup[i].timestamp));
    char tmp[20];
    _clibs_sprintf(tmp, "%.8f,%.8f\0", positions_backup[i].pos.latitude,positions_backup[i].pos.longitude);
    cJSON_AddStringToObject(attributes, "geo_point", tmp);
    cJSON_AddStringToObject(attributes, "created_on", positions_backup[i].timestamp);
  }

  char *rendered = cJSON_Print(root);
  remove_all_chars(rendered, '\n');
  remove_all_chars(rendered, '\t');
  remove_all_chars(rendered, '\r');

  //Sending header




  tU8 buff[] = POST_COMMAND_POSITIONS;
  _clibs_sprintf(buff, POST_COMMAND_POSITION_SUBS, config.fleet_id, config.imei);

  send_at(buff);
  send_at("\r\n");

  for(i=0; i<(sizeof(HTTP_POST_PACKAGE)/sizeof(*HTTP_POST_PACKAGE)); i++){
    send_at(HTTP_POST_PACKAGE[i]);
    send_at("\r\n");
  }

  //Content-Length
  int length_payload_per_position = mystrlen(rendered);
  char str[18];
  _clibs_sprintf(str, "Content-Length: %d\0", length_payload_per_position);
  send_at(str);

  send_at("\r\n");
  send_at("\r\n");

  // HEADER FINISHED

  send_at(rendered);


  free(rendered);
  cJSON_Delete(root);

  send_at("\r\n");
  send_at("\r\n");


}
