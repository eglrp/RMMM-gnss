/* FILE:          modem.c
   PROJECT:       GPS Lib
   SW PACKAGE:    modem handler
------------------------------------------------------------------------------
   DESCRIPTION:   <...>
------------------------------------------------------------------------------
   COPYRIGHT:     (c) <year> STMicroelectronics, (<group>) <site>
------------------------------------------------------------------------------
   Developers:
      AI:   Author Initials
------------------------------------------------------------------------------
   HISTORY:

   Date      | A.I. | Description
   ----------+------+------------------------------------------------------
   yy.mm.dd  |  AI  | Original version
*****************************************************************************/

/*****************************************************************************
   includes
*****************************************************************************/
#include "clibs.h"
#include "gnss_defs.h"
#include "gnss_debug.h"
#include "gnss_events.h"
#include "gnss_api.h"

#include "lld_gpio.h"

#include "svc_uart.h"

/*****************************************************************************
   defines and macros (scope: module-local)
*****************************************************************************/

#define _AT(x) x"\r\n"

#define COM_PORT (0)

#define MAX_READ_BUFFER_SIZE (200)


#define IMEI "8888888885"
#define latitude_s "48.85578817"
#define longitude_s "2.36069871"
#define GET_COMMAND "GET /http?imei="IMEI"&position="latitude_s","longitude_s" HTTP/1.1"
#define GET_COMMAND_SUBST "GET /http?imei="IMEI"&position=%2.8f,%1.8f HTTP/1.1"

/*****************************************************************************
   global variable definitions (scope: module-local)
*****************************************************************************/

gpOS_task_t *modem_task;
gpOS_wakelockid_t modem_wakelock;

char * HTTP_PACKAGE[] = { GET_COMMAND,
						"Host: cloud-logger-159118.appspot.com",
						"Connection: keep-alive",
						"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
						"User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.91 Safari/537.36",
						"X-Client-Data: CIm2yQEIprbJAQiptskBCMG2yQEInobKAQjsiMoB",
						"Accept-Encoding: gzip, deflate, sdch",
						"Accept-Language: es,en-US;q=0.8,en;q=0.6,fr;q=0.4"};

/*****************************************************************************
   function implementations (scope: module-local)
*****************************************************************************/
static gpOS_task_exit_status_t modem_process( gpOS_task_param_t p );

static gnss_events_synch_handler_t *modem_synchdlr_ptr;
static gnss_events_event_id_t modem_syncevent_id = GNSS_EVENTID_FIXREADY;

/*****************************************************************************
   function implementations (scope: module-exported)
*****************************************************************************/

/********************************************//**
 * \brief
 *
 * \param mem_ptr gnss_msg_ptr_t
 * \param mem_size tU32
 * \return void
 *
 ***********************************************/
gpOS_error_t modem_start( gpOS_partition_t *part )
{
  /* Modem Handling process creation */
  modem_task = gpOS_task_create_p( part, modem_process, NULL, 1024, 10, "Modem Process", gpOS_TASK_FLAGS_ACTIVE );

  modem_synchdlr_ptr = gnss_events_synch_handler_create();
  if ( modem_synchdlr_ptr == GNSS_EVENTS_SYNCHANDLER_NONE )
  {
    return ( gpOS_FAILURE );
  }

  gpOS_wakelock_register(&modem_wakelock);

  /* GPIO setup */
  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN0,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN0);

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN11,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN11);

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN13,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionOutput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN13);
  LLD_GPIO_SetStateLow( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN13 );

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN25,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_MODE_A);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN25);

  LLD_GPIO_SetControlMode( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN26,(LLD_GPIO_ModeTy)LLD_GPIO_ALTERNATE_NONE);
  LLD_GPIO_SetDirectionInput( (LLD_GPIO_idTy)GPIO0_REG_START_ADDR, ( LLD_GPIO_PinTy )LLD_GPIO_PIN26);

  /* Open UART port */
  if(svc_uart_open_port(COM_PORT, gpOS_INTERRUPT_NOPRIORITY, LLD_UART_115200_BPS, 256, 256, 4) == gpOS_FAILURE)
  {
    GPS_DEBUG_MSG(( "[modem] Open UART FAILED\r\n"));
    return ( gpOS_FAILURE );
  }
  else
  {
    GPS_DEBUG_MSG(( "[modem] Open UART OK\r\n"));
  }

  return ( gpOS_SUCCESS );
}



void report_error(char *name) {
  GPS_DEBUG_MSG(("[modem] error %s\r\n", name ));
}

void send_at(const char *atc){
  svc_uart_write(COM_PORT, (tU8 *)atc, strlen(atc), gpOS_TIMEOUT_INFINITY);
  GPS_DEBUG_MSG(( "[modem] send=%s\r\n", atc));
}

void remove_all_chars(char* str, char c) {
    char *pr = str, *pw = str;
    while (*pr) {
        *pw = *pr++;
        pw += (*pw != c);
    }
    *pw = '\0';
}

void read_at(char * output, int size){
  tU8 ch;
  tU32 nb, index = 0;
  gpOS_clock_t timeout = 5000000;

  output[index] = '\0';

  while(1){
    nb = svc_uart_read(COM_PORT, &ch, 1, &timeout);

    if(nb == 0){
      break;
    }
    else {
      output[index] = ch;
      index++;
    }

    if((index>3) && !strcmp(&output[index-4], "OK\r\n")){
      break;
    }

    if((index>6) && !strcmp(&output[index-7], "ERROR\r\n")){
      break;
    }
    if(index == (size - 1)){
      GPS_DEBUG_MSG(( "[modem] TOO BIG RESPONSE \r\n", index, ch));
      break;
    }
  }

  output[index] = '\0';

  if (index!=0){
    //to see contents in the logs
    remove_all_chars(output, '\n');
    remove_all_chars(output, '\r');
    GPS_DEBUG_MSG(( "[modem] read=%s\r\n", output));
  }

}

void flush_rx(){

  int size = MAX_READ_BUFFER_SIZE *2; //doubled it here since we were getting a TOO BIG response from server (>200 bytes)
  char buffer[size];
   _clibs_memset(buffer, 0, sizeof(buffer));

   tU8 ch;
   tU32 nb, index = 0;
   gpOS_clock_t timeout = 5000000;

   buffer[index] = '\0';

   while(1){
       nb = svc_uart_read(COM_PORT, &ch, 1, &timeout);
       if(nb == 0){
         break;
       }
       else {
         buffer[index] = ch;
         index++;
       }
       if(index == (size - 1)){
         GPS_DEBUG_MSG(( "[modem] TOO BIG RESPONSE \r\n", index, ch));
         break;
       }
     }
   buffer[index] = '\0';
   if (index!=0){
     //to see contents in the logs
     remove_all_chars(buffer, '\n');
     remove_all_chars(buffer, '\r');
     GPS_DEBUG_MSG(( "[modem] flushed=%s\r\n", buffer));
   }
}

void send_at_get_response(char *atc, gpOS_clock_t *timeout_ms){
  char buffer[MAX_READ_BUFFER_SIZE];

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);

  if(timeout_ms != gpOS_TIMEOUT_IMMEDIATE)
  {
    gpOS_task_delay((*timeout_ms)*1000*gpOS_timer_ticks_per_usec());
  }

  read_at(buffer, sizeof(buffer));
}

boolean_t send_at_check_response(char *atc, char * resp){
  char buffer[MAX_READ_BUFFER_SIZE];
  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  if(strstr(buffer, resp)){
    return true;
  }else{
    return false;
  }
}

boolean_t send_at_until_response(char *atc, char * resp, int max_retries){
  char buffer[MAX_READ_BUFFER_SIZE];
  boolean_t not_timedout = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  while(!strstr(buffer, resp)){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      not_timedout = false;
      break;
    }
    send_at(atc);
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }
  return not_timedout;
}

boolean_t send_at_wait_response(char *atc, char * resp, int max_retries){
  char buffer[MAX_READ_BUFFER_SIZE];
  boolean_t status = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  while(!strstr(buffer, resp)){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      status = false;
      break;
    }
    if(strstr(buffer, "ERROR")){
      status = false;
      break;
    }
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }
  return status;
}


void send_http_package(tDouble lat, tDouble lon){
  int i;

  tU8 buff[] = GET_COMMAND;

  _clibs_sprintf(buff, GET_COMMAND_SUBST, lat, lon);

  send_at(buff);
  send_at("\r\n");

  for(i=1; i<(sizeof(HTTP_PACKAGE)/sizeof(*HTTP_PACKAGE)); i++){
    send_at(HTTP_PACKAGE[i]);
    send_at("\r\n");
  }
  send_at("\r\n");
}

void send_control_z(){
  send_at_get_response("\032", gpOS_TIMEOUT_IMMEDIATE);
  //send_at( "\032");
}

boolean_t wait_urc(char * urc, int max_retries){
  char buffer[2*MAX_READ_BUFFER_SIZE];
  boolean_t not_timedout = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  read_at(buffer, sizeof(buffer));

  while(!strstr(buffer, urc)){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      not_timedout = false;
      break;
    }
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }
  return not_timedout;
}

boolean_t openSocket(){

  if(!send_at_wait_response(_AT("at+sqnsd=1,0,80,\"cloud-logger-159118.appspot.com\",0,8000,1"),"OK", 100)){
      report_error(" - sqnsd failed");
      return FALSE;
  }
}

boolean_t send_position(tDouble lat, tDouble lon)
{
  gpOS_clock_t socekt_at_timeout_ms = 5000;
  gpOS_clock_t std_at_timeout_ms = 100;

  flush_rx();

  send_at_wait_response(_AT("AT+CSQ"), "OK", 10);
  send_at_wait_response(_AT("AT+CPIN?"), "OK", 10);

  if(!send_at_wait_response(_AT("AT+CEREG?"),"+CEREG: 2,1", 5)){
    report_error(" - No network");
    return FALSE;
  }

  if(!send_at_wait_response(_AT("at+cgact?"),"+CGACT: 3,1", 5)){
    report_error(" - No PDN");
    send_at_get_response(_AT("at+cgact=1,3"), &std_at_timeout_ms);
    return FALSE;
  }

  if(send_at_wait_response(_AT("AT+SQNSS"),"+SQNSS: 1,0", 5)){
    if(!openSocket()){
            report_error(" - open socket failed");
            return FALSE;
      }
  }

  send_at(_AT("at+sqnssend=1"));
  send_http_package(lat, lon);
  send_control_z();

  if(!wait_urc("+SQNSRING", 100)){
    report_error(" - No reply from server");
  }else{
    if(!send_at_wait_response(_AT("at+sqnsrecv=1,1500"),"200 OK", 10)){
      report_error(" - server replied with error or did not reply");
    }
    //need to flush rx since the OK\r\n in HTTP response triggered the AT parser to exit too soon
    flush_rx();

  }

  return TRUE;
}

/********************************************//**
 * \brief   A parallel process which reads navigation data from
 *          the gps core and produces position and velocity
 *          output messages to the serial port.
 *          Note that this process should never terminate.
 *
 * \param   p   Task parameter (NULL)
 * \return  None
 *
 ***********************************************/
static gpOS_task_exit_status_t modem_process( gpOS_task_param_t p )
{
  /* Install FIX event ready detection */
  gnss_events_install( modem_syncevent_id, modem_synchdlr_ptr );

  /* Modem init */

  GPS_DEBUG_MSG(( "[modem] Waiting for modem to become online... \r\n"));
  if(!wait_urc("+SYSTART", 50)){
      report_error(" - +SYSTART never received");
  }else{
    GPS_DEBUG_MSG(( "[modem] +SYSTART Received \r\n"));
  }

  gpOS_clock_t std_at_timeout_ms = 100;

  send_at_wait_response(_AT("ATE0"), "OK", 10);
  send_at_wait_response(_AT("AT"), "OK", 10);
  //send_at_wait_response(_AT("AT+CPSMS=0"), "OK", 1); //disable PSM
  //send_at_wait_response(_AT("AT+CMEE=2"), "OK", 10);
  send_at_wait_response(_AT("AT+CFUN=1"), "OK", 10);


  // Just need to config the sockets once
  if(!send_at_wait_response(_AT("at+sqnscfg=1,3,0,0,600,50"),"OK", 5)){
      report_error(" - sqnscfg failed");
      return FALSE;
  }
  if(!send_at_wait_response(_AT("at+sqnscfgext=1,0,0,0"),"OK", 5)){
      report_error(" - sqnscfgext failed");
      return FALSE;
  }

  gpOS_task_delay(5*1000*1000*gpOS_timer_ticks_per_usec());

  while(TRUE)
  {
    /* Wait for the FIX ready event */
    gnss_events_wait( modem_syncevent_id, modem_synchdlr_ptr );

    gpOS_wakelock_acquire(modem_wakelock);

    gnss_fix_store_local(NULL);

    if(gnss_fix_get_pos_status() != NO_FIX)      /* Check if a 2D or 3D Fix is available */
    {
      position_t pos;
      velocity_t vel;

      gnss_fix_get_fil_pos_vel_local(&pos, &vel, NULL);

      if(send_position(pos.latitude, pos.longitude) == FALSE){
        GPS_DEBUG_MSG(( "[modem] Position not sent.\r\n"));
        // If it failed close the socket
        if(!send_at_wait_response(_AT("at+sqnsh=1"),"OK", 50)){
              report_error(" - sqnsh failed");
              return FALSE;
        }
      }
    }
    else
    {
      GPS_DEBUG_MSG(( "[modem] No acquired GNSS FIX yet.\r\n"));
//      if(send_position(48.85578817, 2.36069871) == FALSE){
//           GPS_DEBUG_MSG(( "[modem] False position not sent.\r\n"));
//           if(!send_at_wait_response(_AT("at+sqnsh=1"),"OK", 50)){
//                         report_error(" - sqnsh failed");
//                         return FALSE;
//                   }
//      }
    }
    gpOS_wakelock_release(modem_wakelock, gpOS_TIMEOUT_INFINITY);
  }
}
