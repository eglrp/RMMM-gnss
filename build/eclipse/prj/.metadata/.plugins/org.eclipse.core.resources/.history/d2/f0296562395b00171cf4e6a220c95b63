/*
 * at_module.c
 *
 *  Created on: 24 mai 2017
 *      Author: jsanchez
 */

#include "svc_uart.h"
#include "clibs.h"
#include "gnss_debug.h"
#include "modem.h"
#include "connection_manager.h"

#define _AT(x) x"\r\n"

void report_error(char *name) {
  GPS_DEBUG_MSG(("[POW_app] error %s\r\n", name ));
}

void send_at(const char *atc){
  svc_uart_write(COM_PORT, (tU8 *)atc, strlen(atc), gpOS_TIMEOUT_INFINITY);
  GPS_DEBUG_MSG(( "[POW_app] send=%s\r\n", atc));
}

int read_server_reponse(char * output, int size){
  tU8 ch;
  tU32 nb, index = 0;
  gpOS_clock_t timeout = 5000000;

  output[index] = '\0';

  while(strstr(output, "\r\n\r\nOK\r\n") == NULL){
    nb = svc_uart_read(COM_PORT, &ch, 1, &timeout);

    if(nb == 0){

    }
    else {
      output[index] = ch;
      index++;
    }
  }

  output[index] = '\0';

  GPS_DEBUG_MSG(( "[POW_app] RECV: Expected size=%d\r\n",size));
  GPS_DEBUG_MSG(( "[POW_app] RECV: index=%d\r\n",index));


  return mystrlen(output);


}

boolean_t send_at_wait_response_server(char *atc, char * resp, int max_retries, int max_bytes){
  char buffer[MAX_READ_BUFFER_SIZE];
  boolean_t status_t = true;
  int retries = 0;

  _clibs_memset(buffer, 0, MAX_READ_BUFFER_SIZE);

  send_at(atc);
  int size = read_server_reponse(buffer, MAX_READ_BUFFER_SIZE);

  //Get the index of the first \n to delete the content until the first line break (+SQNSRECV:1, xxxx)
  int i;
  for(i=0;i<strlen(buffer);i++){
    if(buffer[i]=='\n'){
      if(i>5) break; // Avoid the initial line break
    }
  }

  GPS_DEBUG_MSG(( "[POW_app] i=%d\r\n", i));
  //GPS_DEBUG_MSG(( "[POW_app] sin filtrar=%s\r\n", buffer));

  buffer[size]='\0';
  //char buffer2[500];
  //memcpy(buffer2, buffer+250, size-250); // Delete the first line
  //GPS_DEBUG_MSG(( "[POW_app] sin filtrar=%s\r\n", buffer2));

  buffer[mystrlen(buffer)-4] = '\0'; // Delete the OK
  GPS_DEBUG_MSG(( "[POW_app] Deleting the OK\r\n"));

  for (i=0;i<strlen(buffer) - 7;i++) { //Detecting the first line break give us troubles...
    if (buffer[i] == 'H' && buffer[i+1] == 'T' && buffer[i+2] == 'T' && buffer[i+3] == 'P' && buffer[i+4] == '/' && buffer[i+5] == '1' && buffer[i+6] == '.' && buffer[i+7] == '1') {
      // Super cool code here...
      GPS_DEBUG_MSG(( "[POW_app] Deleting the first line... \r\n"));
      memcpy(buffer, &buffer[i], mystrlen(buffer)-i); // Delete the first line
      GPS_DEBUG_MSG(( "[POW_app] Deleted\r\n"));

    }
  }


  //memcpy(buffer, buffer+i+1, mystrlen(buffer)-i); // Delete the first line

  /*for(i=0;i<strlen(buffer);i++){
      if(buffer[i]=='\n'){
        buffer[i]='x'; // Avoid the initial line break
      }
      else if(buffer[i]=='\r'){
        buffer[i]='y'; // Avoid the initial line break
      }
    }*/

  //GPS_DEBUG_MSG(( "[POW_app] filtrada=%s\r\n", buffer));


  int end = 0;
  for(i=0;i<mystrlen(buffer)-8; i++){
    if(buffer[i]=='\r' && buffer[i+1]=='\n' && buffer[i+2]=='\r' && buffer[i+3]=='\n' && buffer[i+4]!='\r' && end==0){
      buffer[i]=' ';
      buffer[i+1]=' ';
    }
    if(buffer[i]=='\r' && buffer[i+1]=='\n' && buffer[i+2]=='\r' && buffer[i+3]=='\n' && buffer[i+4]=='\r' && buffer[i+5]=='\n' && buffer[i+6]=='\r' && buffer[i+7]=='\n' && buffer[i+8]!='\r'){
      buffer[i]=' ';
      buffer[i+1]=' ';
      buffer[i+2]=' ';
      buffer[i+3]=' ';
      end=1;
    }
  }
  GPS_DEBUG_MSG(( "[POW_app] Deleted break lines\r\n"));
  buffer[mystrlen(buffer)]='\0';
  //GPS_DEBUG_MSG(( "[POW_app] sentencia completa=%s\r\n", buffer));
  //GPS_DEBUG_MSG(( "[POW_app] RECV: Real size=%d\r\n", mystrlen(buffer)));
  //buffer[mystrlen(buffer)-i] = '\0';
  /*for(i=0;i<strlen(buffer);i++){
    if(buffer[i]=='\n'){
      buffer[i]='x'; // Avoid the initial line break
    }
    if(buffer[i]=='\r'){
      buffer[i]='y'; // Avoid the initial line break
    }
  }*/
  //GPS_DEBUG_MSG(( "[POW_app] sentencia completa=%s\r\n", buffer));

  GPS_DEBUG_MSG(( "[POW_app] Analysing the answer...\r\n"));
  analyse_response(buffer);

  //free(buffer);

  return status_t;
}

boolean_t at_recv_data(int port, int max_bytes);

void read_at(char * output, int size){
  tU8 ch;
  tU32 nb, index = 0;
  gpOS_clock_t timeout = 5000;

  output[index] = '\0';
  //tU8 ch[64];


  while(1){
    nb = svc_uart_read(COM_PORT, &ch, 1, &timeout);

    if(nb == 0){
      break;
    }
    else {
      output[index] = ch;
      index++;
    }

    if((index>2) && !strcmp(&output[index-2],"\r\n")){
      //GPS_DEBUG_MSG(( "[POW_app] Salto encontrado\r\n"));

      if((index>12) && !strcmp(&output[index-11], "+SYSSTART\r\n")){
        GPS_DEBUG_MSG(( "[POW_app] Leido URC SYSSTART\r\n"));
        break;
      }
      if((index>3) && !strcmp(&output[index-4], "OK\r\n")){
        break;
      }
      if(strstr(output, "+SQNSRING:") != NULL){
        int data_size = get_size(output);
        GPS_DEBUG_MSG(( "[POW_app] RING found, size: %d\r\n", data_size));
        at_recv_data(PORT,1500);
        //char buffer[MAX_READ_BUFFER_SIZE];
        //read_server_reponse(buffer, MAX_READ_BUFFER_SIZE);
        break;
      }
      /*if(strstr(output, "+SQNSRECV:") != NULL){
        GPS_DEBUG_MSG(( "[POW_app] RECV Encontrado\r\n"));
        int data_size = get_size(output);
        char buffer[data_size+1];
        read_server_reponse(buffer, data_size);
        break;
      }*/

      /*if((index>15) && !strcmp(&output[index-16], "204 No Content\r\n")){
        GPS_DEBUG_MSG(( "[POW_app] The cloud server has received the positions\r\n"));
        break;
      }

      if((index>12) && !strcmp(&output[index-13], "201 Created\r\n")){
        GPS_DEBUG_MSG(( "[POW_app] New config\r\n"));
        break;
      }*/

      if((index>6) && !strcmp(&output[index-7], "ERROR\r\n")){
        break;
      }

    }


  }

  output[index] = '\0';

  if (index!=0){
    //to see contents in the logs
    remove_all_chars(output, '\n');
    remove_all_chars(output, '\r');
    GPS_DEBUG_MSG(( "[POW_app] read=%s\r\n", output));
  }

}

/*
 * Function to send an AT command and returns the result
 */

char * send_at_read_response(char *atc, int max_retries){
  char buffer[MAX_READ_BUFFER_SIZE];
  boolean_t not_timedout = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  while(strstr(buffer, "ERROR")){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      not_timedout = false;
      break;
    }
    send_at(atc);
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }

  char * temp = (char*)malloc(strlen(buffer) * sizeof(char));
  strcpy(temp, buffer);
  return temp;
}

void send_at_get_response(char *atc, gpOS_clock_t *timeout_ms){
  char buffer[MAX_READ_BUFFER_SIZE];

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);

  if(timeout_ms != gpOS_TIMEOUT_IMMEDIATE)
  {
    gpOS_task_delay((*timeout_ms)*1000*gpOS_timer_ticks_per_usec());
  }

  read_at(buffer, sizeof(buffer));
}

boolean_t send_at_check_response(char *atc, char * resp){
  char buffer[MAX_READ_BUFFER_SIZE];
  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  if(strstr(buffer, resp)){
    return true;
  }else{
    return false;
  }
}

boolean_t send_at_until_response(char *atc, char * resp, int max_retries){
  char buffer[MAX_READ_BUFFER_SIZE];
  boolean_t not_timedout = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  while(!strstr(buffer, resp)){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      not_timedout = false;
      break;
    }
    send_at(atc);
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }
  return not_timedout;
}

boolean_t send_at_wait_response(char *atc, char * resp, int max_retries){
  char buffer[MAX_READ_BUFFER_SIZE];
  boolean_t status = true;
  int retries = 0;

  _clibs_memset(buffer, 0, sizeof(buffer));

  send_at(atc);
  read_at(buffer, sizeof(buffer));
  while(!strstr(buffer, resp)){
    gpOS_task_delay(100*1000*gpOS_timer_ticks_per_usec());
    if(retries++ >= max_retries){
      status = false;
      break;
    }
    if(strstr(buffer, "ERROR")){
      status = false;
      break;
    }
    _clibs_memset(buffer, 0, sizeof(buffer));
    read_at(buffer, sizeof(buffer));
  }
  return status;
}


boolean_t at_disable_echo(){
  return send_at_wait_response(_AT("ATE0"), "OK", 10);
}

boolean_t at_check(){
  return send_at_wait_response(_AT("AT"), "OK", 10);
}

boolean_t at_disable_PSM(){
  return send_at_wait_response(_AT("AT+CPSMS=0"), "OK", 1);
}

/*
   Mobile Equipment Errors

    0 disable result code and use ERROR instead
    1 enable result code and use numeric <err> values
    2 enable result code and use verbose <err> values
 */

boolean_t at_configure_errors(int i){

  switch(i){
    case 0:
      return send_at_wait_response(_AT("AT+CMEE=0"), "OK", 10);
      break;
    case 1:
      return send_at_wait_response(_AT("AT+CMEE=1"), "OK", 10);
      break;
    case 2:
      return send_at_wait_response(_AT("AT+CMEE=2"), "OK", 10);
      break;
    default:
      return send_at_wait_response(_AT("AT+CMEE=0"), "OK", 10);
      break;
  }
}

boolean_t at_activate_modem(){
  return send_at_wait_response(_AT("AT+CFUN=1"), "OK", 10);
}

boolean_t at_configure_socket(int socket_id, int pdp_id, int packet_size, int exchange_timeout, int connection_timeout, int data_sending_timeout){
  char str[30];
  _clibs_sprintf(str, "at+sqnscfg=%d,%d,%d,%d,%d,%d\r\n", socket_id, pdp_id, packet_size, exchange_timeout, connection_timeout, data_sending_timeout);
  return send_at_wait_response(str, "OK", 10);
}


//Hay parametros opcionales
boolean_t at_extended_configure_socket(int socket_id, int sring_mode, int rcv_data_mode, int keep_alive){
  char str[30];
  _clibs_sprintf(str, "at+sqnscfgext=%d,%d,%d,%d\r\n", socket_id, sring_mode, rcv_data_mode, keep_alive);
  return send_at_wait_response(str, "OK", 10);
}

boolean_t at_extended_configure_socket_2(int socket_id, int sring_mode, int rcv_data_mode, int keep_alive, int listen_auto_reponse){
  char str[33];
  _clibs_sprintf(str, "at+sqnscfgext=%d,%d,%d,%d,%d\r\n", socket_id, sring_mode, rcv_data_mode, keep_alive, listen_auto_reponse);
  return send_at_wait_response(str, "OK", 10);
}

boolean_t at_extended_configure_socket_3(int socket_id, int sring_mode, int rcv_data_mode, int keep_alive, int listen_auto_reponse, int send_data_mode){
  char str[33];
  _clibs_sprintf(str, "at+sqnscfgext=%d,%d,%d,%d,%d,%d\r\n", socket_id, sring_mode, rcv_data_mode, keep_alive, listen_auto_reponse, send_data_mode);
  return send_at_wait_response(str, "OK", 10);
}

char* at_get_imei(){
  char *ptr = (char*) _clibs_malloc(20 * sizeof(char));
  _clibs_strcpy(ptr, send_at_read_response(_AT("AT+CGSN"),5));
  int i = 0;
  while(ptr[i] != '\0')
  {
    i++;

  }
  ptr[i-2] = '\0'; // Delete the OK

  //char imei[] = send_at_read_response(_AT("AT+CGSN"),5);
  //imei[strlen(imei)-2] = 0;                                  // Delete the last two characters i.e 1234567OK
  return ptr;
}

void at_get_network_time(char* output){
  //char *ptr = (char*) _clibs_malloc(27 * sizeof(char));

  _clibs_strcpy(output, send_at_read_response(_AT("AT+CCLK?"),10));
  int i = 0;
  while(output[i] != '\0')
  {
    i++;

  }
  output[i-2] = '\0'; // Delete the OK
  GPS_DEBUG_MSG(( "[POW_app] Before return, date=%s\r\n", output));
}

boolean_t at_socket_shutdown(int socket_id){
  char str[30];
  _clibs_sprintf(str, "at+sqnsh=%d\r\n", socket_id);
  return send_at_wait_response(str, "OK", 50);
}

boolean_t at_socket_dial(int socket_id, int protocol, int port, char * ip, int closure_behaviour, int udp_port, int conn_mode){
  char str[100];
  _clibs_sprintf(str, "at+sqnsd=%d,%d,%d,%s,%d,%d,%d\r\n", socket_id, protocol, port, ip, closure_behaviour, udp_port, conn_mode);
  return send_at_wait_response(str, "OK", 150);
}

boolean_t at_check_signal_quality(){
  return send_at_wait_response(_AT("AT+CSQ"), "OK", 10);
}

boolean_t at_check_pin_status(){
  return send_at_wait_response(_AT("AT+CPIN?"), "OK", 10);
}

boolean_t at_check_eps_registration_status(){
  return send_at_wait_response(_AT("AT+CEREG?"),"+CEREG: 2,1", 5);
}

boolean_t at_check_pdp_context(){
  return send_at_wait_response(_AT("at+cgact?"),"+CGACT: 1,1", 5);
}

void at_activate_pdp(){
  gpOS_clock_t std_at_timeout_ms = 100;
  send_at_get_response(_AT("at+cgact=1,1"), &std_at_timeout_ms);
}

boolean_t at_is_socket_closed(int socket){
  char str[15];
  _clibs_sprintf(str, "+SQNSS: %d,0", socket);
  return send_at_wait_response(_AT("AT+SQNSS"),str, 5);
}

boolean_t at_recv_data(int port, int max_bytes){
  char str[25];
  _clibs_sprintf(str, "at+sqnsrecv=%d,%d\r\n",port,max_bytes);
  return send_at_wait_response_server(str,"OK",1,max_bytes);
}

/*char * at_recv_data_to_analyse(int port, int max_bytes){
  char str[25];
  _clibs_sprintf(str, "at+sqnsrecv=%d,%d\r\n",port,max_bytes);
  char response[] = send_at_read_response(str,5);
  return response;
}*/

boolean_t at_send_data(int port){
  char str[20];
  _clibs_sprintf(str, "at+sqnssend=%d\r\n",port);
  return send_at_wait_response(str,"OK", 10);
}


